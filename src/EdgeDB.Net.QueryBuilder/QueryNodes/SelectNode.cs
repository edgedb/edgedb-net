using EdgeDB.Builders;
using EdgeDB.Interfaces.Queries;
using EdgeDB.QueryNodes.Contexts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace EdgeDB.QueryNodes
{
    /// <summary>
    ///     Represents a 'SELECT' node
    /// </summary>
    internal class SelectNode : QueryNode<SelectContext>
    {
        private QueryStringWriter.Proxy? _filter;
        private QueryStringWriter.Proxy? _limit;
        private QueryStringWriter.Proxy? _offset;
        private QueryStringWriter.Proxy? _orderBy;
        private SelectShape? _shape;

        /// <inheritdoc/>
        public SelectNode(NodeBuilder builder) : base(builder) { }

        /// <summary>
        ///     Wraps the parent node and removes it from the query builder.
        /// </summary>
        private void WrapParent(QueryNode parent)
        {
            // remove the node from the query builder
            Builder.Nodes.Remove(parent);
            RequiresIntrospection = parent.RequiresIntrospection;
            // make the node a child of this one
            SubNodes.Add(parent);
        }

        /// <inheritdoc/>
        public override void Visit()
        {
            if (Context.IncludeShape && Context.Expression is null)
            {
                // build the shape
                var shape = Context.Shape ?? BaseShapeBuilder.CreateDefault(GetOperatingType());

                _shape = shape.GetShape();
            }

            if(Context.Shape is not null && Context.Expression is not null)
            {
                // TODO: what..? figure out what this did
                //Context.SelectName = FlattenTranslateExpression(Context.Expression);

                _shape = Context.Shape.GetShape();
            }

            // is this node autogenerated and does it have a parent?
            if (Parent is not null)
                WrapParent(Parent);
        }

        /// <inheritdoc/>
        public override void FinalizeQuery(QueryStringWriter writer)
        {
            if(SubNodes.Count > 1)
            {
                throw new NotSupportedException("Got more than one child node for select statement (this is a bug)");
            }

            // if parent is defined, our select logic was generated in the
            // visit step, we can just return out.
            if (SubNodes.Count == 1)
            {
                var node = SubNodes.First();

                // set introspection details & finalize
                node.SchemaInfo = SchemaInfo;


                writer.Append($"select ").Wrapped(writer =>
                {
                    var pos = writer.Position;
                    node.FinalizeQuery(writer);

                    // no query was written?
                    if (pos != writer.Position) return;

                    if(node.Context.SetAsGlobal && !string.IsNullOrEmpty(node.Context.GlobalName))
                    {
                        // wrap global name
                        writer.Append(node.Context.GlobalName);
                    }
                    else
                        throw new InvalidOperationException($"Cannot resolve parent node {Parent}'s query");
                });

                // append the shape of the parents node operating type if we should include ours
                if (Context.IncludeShape && _shape is not null)
                {
                    _shape.Compile(writer, (writer, expression) =>
                    {
                        using var consumer = NodeTranslationContext.CreateContextConsumer(expression.Root);
                        ExpressionTranslator.ContextualTranslate(expression.Expression, consumer, writer);
                    });
                }
            }
            else if(!Context.IncludeShape)
            {
                if (Context.Expression is not null)
                {
                    var expressionWriter = writer
                        .Append("select ");

                    if (Context.SelectName is not null)
                        expressionWriter.Append(Context.SelectName).Append(' ');

                    TranslateExpression(Context.Expression, expressionWriter);
                }
                else
                    writer.Insert(0, $"select {Context.SelectName ?? OperatingType.GetEdgeDBTypeName()}");
            }
            else if (_shape is not null)
            {
                var shapeWriter = writer
                    .Append("select ");

                if (!Context.IsFreeObject)
                    shapeWriter.Append(Context.SelectName ?? OperatingType.GetEdgeDBTypeName());

                _shape.Compile(shapeWriter, (writer, expression) =>
                {
                    using var consumer = NodeTranslationContext.CreateContextConsumer(expression.Root);
                    ExpressionTranslator.ContextualTranslate(expression.Expression, consumer, writer);
                });
            }

            if (_filter is not null)
                writer.Append(_filter);

            if (_orderBy is not null)
                writer.Append(_orderBy);

            if (_offset is not null)
                writer.Append(_offset);

            if (_limit is not null)
                writer.Append(_limit);
        }

        /// <summary>
        ///     Adds a filter to the select node.
        /// </summary>
        /// <param name="expression">The filter predicate to add.</param>
        public void Filter(LambdaExpression expression)
        {
            _filter ??= writer =>
            {
                writer.Append(" filter ");
                TranslateExpression(expression, writer);
            };
        }

        /// <summary>
        ///     Adds a order by statement to the select node.
        /// </summary>
        /// <param name="asc">
        ///     <see langword="true"/> if the ordered result should be ascending first.
        /// </param>
        /// <param name="selector">The lambda property selector on which to order by.</param>
        /// <param name="nullPlacement">The <see langword="null"/> placement for null values.</param>
        public void OrderBy(bool asc, LambdaExpression selector, OrderByNullPlacement? nullPlacement)
        {
            var direction = asc ? "asc" : "desc";

            _orderBy ??= writer =>
            {
                writer.Append(" order by ");
                TranslateExpression(selector, writer);
                writer.Append(" ").Append(direction);

                if (nullPlacement.HasValue)
                    writer.Append(nullPlacement.Value.ToString().ToLowerInvariant());
            };
        }

        /// <summary>
        ///     Adds a offset statement to the select node.
        /// </summary>
        /// <param name="offset">The number of elements to offset by.</param>
        internal void Offset(long offset)
        {
            _offset ??= writer => writer.Append(" offset ").Append(offset);
        }

        /// <summary>
        ///     Adds a offset statement to the select node.
        /// </summary>
        /// <param name="exp">The expression returning the number of elements to offset by.</param>
        internal void OffsetExpression(LambdaExpression exp)
        {
            _offset ??= writer =>
            {
                writer.Append(" offset ");
                TranslateExpression(exp, writer);
            };
        }

        /// <summary>
        ///     Adds a limit statement to the select node.
        /// </summary>
        /// <param name="limit">The number of element to limit to.</param>
        internal void Limit(long limit)
        {
            _limit ??= writer => writer.Append(" limit ").Append(limit);
        }

        /// <summary>
        ///     Adds a limit statement to the select node.
        /// </summary>
        /// <param name="exp">The expression returning the number of elements to limit to.</param>
        internal void LimitExpression(LambdaExpression exp)
        {
            _limit ??= writer =>
            {
                writer.Append(" limit ");
                TranslateExpression(exp, writer);
            };
        }
    }
}
