using EdgeDB.Builders;
using EdgeDB.Interfaces.Queries;
using EdgeDB.QueryNodes.Contexts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace EdgeDB.QueryNodes
{
    /// <summary>
    ///     Represents a 'SELECT' node
    /// </summary>
    internal class SelectNode : QueryNode<SelectContext>
    {
        private string? _shape;

        /// <inheritdoc/>
        public SelectNode(NodeBuilder builder) : base(builder) { }
        
        /// <summary>
        ///     Wraps the parent node and removes it from the query builder.
        /// </summary>
        private void WrapParent(QueryNode parent)
        {
            // remove the node from the query builder
            Builder.Nodes.Remove(parent);
            RequiresIntrospection = parent.RequiresIntrospection;
            // make the node a child of this one
            SubNodes.Add(parent);
        }

        /// <inheritdoc/>
        public override void Visit()
        {
            if (Context.IncludeShape && Context.Expression is null)
            {
                // build the shape
                var shape = Context.Shape ?? BaseShapeBuilder.CreateDefault(GetOperatingType());

                NodeTranslationContext translationContext = new(this);

                _shape = shape.GetShape().Compile(element =>
                {
                    using var consumer = translationContext.CreateContextConsumer(element.Root);
                    return ExpressionTranslator.ContextualTranslate(element.Expression, consumer);
                });
            }

            if(Context.Shape is not null && Context.Expression is not null)
            {
                Context.SelectName = TranslateExpression(Context.Expression);

                NodeTranslationContext translationContext = new(this);

                _shape = Context.Shape.GetShape().Compile(element =>
                {
                    using var consumer = translationContext.CreateContextConsumer(element.Root);
                    return ExpressionTranslator.ContextualTranslate(element.Expression, consumer);
                });
            } 

            // is this node autogenerated and does it have a parent?
            if (Parent is not null)
                WrapParent(Parent);
        }

        /// <inheritdoc/>
        public override void FinalizeQuery()
        {
            // if parent is defined, our select logic was generated in the
            // visit step, we can just return out.
            if (SubNodes.Count == 1)
            {
                var node = SubNodes.First();

                // set introspection details & finalize
                node.SchemaInfo = SchemaInfo;
                node.FinalizeQuery();

                var result = node.Build();

                var selectTarget = result.Query;

                if (string.IsNullOrEmpty(selectTarget))
                {
                    if(node.Context.SetAsGlobal && !string.IsNullOrEmpty(node.Context.GlobalName))
                    {
                        // wrap global name
                        selectTarget = node.Context.GlobalName;
                    }

                    throw new InvalidOperationException($"Cannot resolve parent node {Parent}'s query");
                }

                Query.Append($"select ({selectTarget})");

                // append the shape of the parents node operating type if we should include ours
                if (Context.IncludeShape)
                    Query.Append($" {_shape}");
                return;
            }
            else if(SubNodes.Count > 1)
            {
                throw new NotSupportedException("Got more than one child node for select statement (this is a bug)");
            }

            if(!Context.IncludeShape)
            {
                if (Context.Expression is not null)
                {
                    var translatedExpression = TranslateExpression(Context.Expression);
                    Query.Insert(0, $"select{(Context.SelectName is not null ? $" {Context.SelectName}" : string.Empty)} {translatedExpression}");

                }
                else
                    Query.Insert(0, $"select {Context.SelectName ?? OperatingType.GetEdgeDBTypeName()}");
                return;
            }

            if(_shape is not null)
                Query.Insert(0, $"select {(!Context.IsFreeObject ? (Context.SelectName ?? OperatingType.GetEdgeDBTypeName()) : string.Empty)} {_shape}");
        }

        /// <summary>
        ///     Adds a filter to the select node.
        /// </summary>
        /// <param name="expression">The filter predicate to add.</param>
        public void Filter(LambdaExpression expression)
        {
            var parsedExpression = TranslateExpression(expression);
            Query.Append($" filter {parsedExpression}");
        }

        /// <summary>
        ///     Adds a ordery by statement to the select node.
        /// </summary>
        /// <param name="asc">
        ///     <see langword="true"/> if the ordered result should be ascending first.
        /// </param>
        /// <param name="selector">The lambda property selector on which to order by.</param>
        /// <param name="nullPlacement">The <see langword="null"/> placement for null values.</param>
        public void OrderBy(bool asc, LambdaExpression selector, OrderByNullPlacement? nullPlacement)
        {
            var parsedExpression = TranslateExpression(selector);
            var direction = asc ? "asc" : "desc";
            Query.Append($" order by {parsedExpression} {direction}{(nullPlacement.HasValue ? $" {nullPlacement.Value.ToString().ToLowerInvariant()}" : "")}");
        }

        /// <summary>
        ///     Adds a offest statement to the select node.
        /// </summary>
        /// <param name="offset">The number of elements to offset by.</param>
        internal void Offset(long offset)
        {
            Query.Append($" offset {offset}");
        }

        /// <summary>
        ///     Adds a offest statement to the select node.
        /// </summary>
        /// <param name="exp">The expression returing the number of elements to offset by.</param>
        internal void OffsetExpression(LambdaExpression exp)
        {
            Query.Append($" offset {TranslateExpression(exp)}");
        }

        /// <summary>
        ///     Adds a limit statement to the select node.
        /// </summary>
        /// <param name="limit">The number of element to limit to.</param>
        internal void Limit(long limit)
        {
            Query.Append($" limit {limit}");
        }

        /// <summary>
        ///     Adds a limit statement to the select node.
        /// </summary>
        /// <param name="exp">The expression returing the number of elements to limit to.</param>
        internal void LimitExpression(LambdaExpression exp)
        {
            Query.Append($" limit {TranslateExpression(exp)}");
        }
    }
}
