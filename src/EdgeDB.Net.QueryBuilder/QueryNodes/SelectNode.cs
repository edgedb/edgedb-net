using EdgeDB.Builders;
using EdgeDB.Interfaces.Queries;
using EdgeDB.QueryNodes.Contexts;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using System.Text;
using System.Threading.Tasks;

namespace EdgeDB.QueryNodes
{
    /// <summary>
    ///     Represents a 'SELECT' node
    /// </summary>
    internal class SelectNode : QueryNode<SelectContext>
    {
        private SelectShape? _shape;

        /// <inheritdoc/>
        public SelectNode(NodeBuilder builder) : base(builder) { }

        /// <summary>
        ///     Wraps the parent node and removes it from the query builder.
        /// </summary>
        private void WrapParent(QueryNode parent)
        {
            // remove the node from the query builder
            Builder.Nodes.Remove(parent);
            RequiresIntrospection = parent.RequiresIntrospection;
            // make the node a child of this one
            SubNodes.Add(parent);
        }

        /// <inheritdoc/>
        public override void Visit()
        {
            if (Context.IncludeShape && Context.Expression is null)
            {
                // build the shape
                var shape = Context.Shape ?? BaseShapeBuilder.CreateDefault(GetOperatingType());

                _shape = shape.GetShape();
            }

            if(Context.Shape is not null && Context.Expression is not null)
            {
                // TODO: what..? figure out what this did
                //Context.SelectName = FlattenTranslateExpression(Context.Expression);

                _shape = Context.Shape.GetShape();
            }

            // is this node autogenerated and does it have a parent?
            if (Parent is not null)
                WrapParent(Parent);
        }

        /// <inheritdoc/>
        public override void FinalizeQuery()
        {
            // if parent is defined, our select logic was generated in the
            // visit step, we can just return out.
            if (SubNodes.Count == 1)
            {
                var node = SubNodes.First();

                // set introspection details & finalize
                node.SchemaInfo = SchemaInfo;
                node.FinalizeQuery();

                var result = node.Build();

                var selectTarget = result.Query;

                if (string.IsNullOrEmpty(selectTarget))
                {
                    if(node.Context.SetAsGlobal && !string.IsNullOrEmpty(node.Context.GlobalName))
                    {
                        // wrap global name
                        selectTarget = node.Context.GlobalName;
                    }
                    else
                        throw new InvalidOperationException($"Cannot resolve parent node {Parent}'s query");
                }

                Writer.Append($"select ({selectTarget})");

                // append the shape of the parents node operating type if we should include ours
                if (Context.IncludeShape && _shape is not null)
                {
                    _shape.Compile(Writer, (writer, expression) =>
                    {
                        using var consumer = NodeTranslationContext.CreateContextConsumer(expression.Root);
                        ExpressionTranslator.ContextualTranslate(expression.Expression, consumer, writer);
                    });
                }

                return;
            }
            else if(SubNodes.Count > 1)
            {
                throw new NotSupportedException("Got more than one child node for select statement (this is a bug)");
            }

            if(!Context.IncludeShape)
            {
                if (Context.Expression is not null)
                {
                    var writer = Writer.GetPositionalWriter(0)
                        .Append("select");

                    if (Context.SelectName is not null)
                        writer.Append(" ").Append(Context.SelectName);

                    TranslateExpression(Context.Expression, writer);
                }
                else
                    Writer.Insert(0, $"select {Context.SelectName ?? OperatingType.GetEdgeDBTypeName()}");

                return;
            }

            if (_shape is not null)
            {
                var writer = Writer.GetPositionalWriter(0)
                    .Append("select ");

                if (!Context.IsFreeObject)
                    writer.Append(Context.SelectName ?? OperatingType.GetEdgeDBTypeName());

                _shape.Compile(writer, (writer, expression) =>
                {
                    using var consumer = NodeTranslationContext.CreateContextConsumer(expression.Root);
                    ExpressionTranslator.ContextualTranslate(expression.Expression, consumer, writer);
                });
            }
        }

        /// <summary>
        ///     Adds a filter to the select node.
        /// </summary>
        /// <param name="expression">The filter predicate to add.</param>
        public void Filter(LambdaExpression expression)
        {
            Writer.Append(" filter ");
            TranslateExpression(expression, Writer);
        }

        /// <summary>
        ///     Adds a order by statement to the select node.
        /// </summary>
        /// <param name="asc">
        ///     <see langword="true"/> if the ordered result should be ascending first.
        /// </param>
        /// <param name="selector">The lambda property selector on which to order by.</param>
        /// <param name="nullPlacement">The <see langword="null"/> placement for null values.</param>
        public void OrderBy(bool asc, LambdaExpression selector, OrderByNullPlacement? nullPlacement)
        {
            var direction = asc ? "asc" : "desc";

            Writer.Append(" order by ");
            TranslateExpression(selector, Writer);
            Writer.Append(" ").Append(direction);

            if (nullPlacement.HasValue)
                Writer.Append(nullPlacement.Value.ToString().ToLowerInvariant());
        }

        /// <summary>
        ///     Adds a offset statement to the select node.
        /// </summary>
        /// <param name="offset">The number of elements to offset by.</param>
        internal void Offset(long offset)
        {
            Writer.Append(" offset ").Append(offset);
        }

        /// <summary>
        ///     Adds a offset statement to the select node.
        /// </summary>
        /// <param name="exp">The expression returning the number of elements to offset by.</param>
        internal void OffsetExpression(LambdaExpression exp)
        {
            Writer.Append(" offset ");
            TranslateExpression(exp, Writer);
        }

        /// <summary>
        ///     Adds a limit statement to the select node.
        /// </summary>
        /// <param name="limit">The number of element to limit to.</param>
        internal void Limit(long limit)
        {
            Writer.Append(" limit ").Append(limit);
        }

        /// <summary>
        ///     Adds a limit statement to the select node.
        /// </summary>
        /// <param name="exp">The expression returning the number of elements to limit to.</param>
        internal void LimitExpression(LambdaExpression exp)
        {
            Writer.Append(" limit ");
            TranslateExpression(exp, Writer);
        }
    }
}
