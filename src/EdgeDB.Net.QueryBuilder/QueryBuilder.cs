using EdgeDB.Builders;
using EdgeDB.Compiled;
using EdgeDB.Interfaces;
using EdgeDB.Interfaces.Queries;
using EdgeDB.QueryNodes;
using EdgeDB.Schema;
using EdgeDB.Translators.Expressions;
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;
using System.Linq.Expressions;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace EdgeDB
{
    /// <summary>
    ///     Represents a query builder used to build queries against <typeparamref name="TType"/>.
    /// </summary>
    /// <typeparam name="TType">The type that this query builder is currently building queries for.</typeparam>
    public partial class QueryBuilder<TType> : QueryBuilder<TType, QueryContextSelf<TType>>
    {
        public QueryBuilder()
        { }

        internal QueryBuilder(QueryBuilderState state)
            : base(state) { }
    }

    /// <summary>
    ///     Represents a query builder used to build queries against <typeparamref name="TType"/>
    ///     with the context type <typeparamref name="TContext"/>.
    /// </summary>
    /// <typeparam name="TType">The type that this query builder is currently building queries for.</typeparam>
    /// <typeparam name="TContext">The context type used for contextual expressions.</typeparam>
    public partial class QueryBuilder<TType, TContext> : IQueryBuilder<TType, TContext> where TContext : IQueryContext
    {
        /// <inheritdoc/>
        public bool RequiresIntrospection
            => Nodes.Any(x => x.RequiresIntrospection);

        /// <summary>
        ///     A list of query nodes that make up the current query builder.
        /// </summary>
        private List<QueryNode> Nodes
            => _state.Nodes;

        /// <summary>
        ///     The current user defined query node.
        /// </summary>
        private QueryNode? CurrentUserNode
        {
            get
            {
                var latestNode = Nodes.LastOrDefault(x => !x.IsAutoGenerated);

                if (latestNode is not null)
                    return latestNode;

                if (Nodes.Count == 0)
                    return null;

                for (int i = Nodes.Count - 1; i >= 0; i--)
                {
                    var n = Nodes[i];
                    if (n.IsAutoGenerated)
                    {
                        var child = n.SubNodes.FirstOrDefault(x => !x.IsAutoGenerated);
                        if (child is not null)
                            return child;
                    }
                }

                throw new NotSupportedException("No user defined query node found. (this is most likely a bug)");
            }
        }

        /// <summary>
        ///     A list of query globals used by this query builder.
        /// </summary>
        private List<QueryGlobal> QueryGlobals
            => _state.Globals;

        /// <summary>
        ///     The current schema introspection info if it has been fetched.
        /// </summary>
        private SchemaInfo? SchemaInfo { get => _state.SchemaInfo; set => _state.SchemaInfo = value; }

        /// <summary>
        ///     A dictionary of query variables used by the <see cref="Nodes"/>.
        /// </summary>
        private Dictionary<string, object?> QueryVariables
            => _state.Variables;

        private readonly QueryBuilderState _state;

        /// <summary>
        ///     Constructs an empty query builder.
        /// </summary>
        public QueryBuilder() : this(QueryBuilderState.Empty)
        {}

        /// <summary>
        ///     Constructs a query builder with the given nodes, globals, and variables.
        /// </summary>
        /// <param name="state">The state information for this querybuilder.</param>
        internal QueryBuilder(QueryBuilderState state)
        {
            _state = state;
        }

        /// <summary>
        ///     Constructs a query builder with the given schema introspection info.
        /// </summary>
        /// <param name="info">The schema introspection info.</param>
        internal QueryBuilder(SchemaInfo info)
            : this()
        {
            SchemaInfo = info;
        }

        /// <summary>
        ///     Adds a query variable to the current query builder.
        /// </summary>
        /// <param name="name">The name of the variable.</param>
        /// <param name="value">The value of the variable.</param>
        internal void AddQueryVariable(string name, object? value)
            => QueryVariables[name] = value;

        /// <summary>
        ///     Copies this query builders nodes, globals, and variables
        ///     to a new query builder with a given generic type.
        /// </summary>
        /// <typeparam name="TTarget">The target type of the new query builder.</typeparam>
        /// <returns>
        ///     A new <see cref="QueryBuilder{TTarget, TContext}"/> with the target type.
        /// </returns>
        private QueryBuilder<TTarget, TContext> EnterNewType<TTarget>()
        {
            if (this is QueryBuilder<TTarget, TContext> s)
                return s;

            return new(_state);
        }

        /// <summary>
        ///     Copies this query builders nodes, globals, and variables
        ///     to a new query builder with the given context type.
        /// </summary>
        /// <typeparam name="TNewContext">The target context type of the new builder.</typeparam>
        /// <returns>
        ///     A new <see cref="QueryBuilder{TType, TNewContext}"/> with the target context type.
        /// </returns>
        internal QueryBuilder<TType, TNewContext> EnterNewContext<TNewContext>()
            where TNewContext : IQueryContext
        {
            if (this is QueryBuilder<TType, TNewContext> s)
                return s;

            return new(_state);
        }

        /// <summary>
        ///     Adds a new node to this query builder.
        /// </summary>
        /// <typeparam name="TNode">The type of the node</typeparam>
        /// <param name="context">The specified nodes context.</param>
        /// <param name="autoGenerated">
        ///     Whether or not this node was added by the user or was added as
        ///     part of an implicit build step.
        /// </param>
        /// <param name="child">The child node for the newly added node.</param>
        /// <returns>An instance of the specified <typeparamref name="TNode"/>.</returns>
        private TNode AddNode<TNode>(NodeContext context, bool autoGenerated = false, QueryNode? child = null)
            where TNode : QueryNode
        {
            // create a new builder for the node.
            var builder = new NodeBuilder(context, QueryGlobals, Nodes, QueryVariables)
            {
                IsAutoGenerated = autoGenerated
            };

            // construct the node.
            var node = (TNode)Activator.CreateInstance(typeof(TNode), builder)!;

            if(child is not null)
            {
                node.SubNodes.Add(child);
                child.Parent = node;
                Nodes.Remove(child);
            }

            // visit the node
            node.Visit();

            Nodes.Add(node);

            return node;
        }

        /// <summary>
        ///     Compiles the current query builder into its <see cref="CompiledQuery"/> form.
        /// </summary>
        /// <returns>
        ///     A <see cref="CompiledQuery"/>.
        /// </returns>
        internal CompiledQuery CompileInternal(CompileContext? context = null)
        {
            context ??= new CompileContext();

            using var writer = new QueryWriter(context.Debug);

            CompileInternal(writer, context);

            if (!context.Debug) return new CompiledQuery(writer.Compile().ToString(), QueryVariables);

            var compiled = writer.CompileDebug();
            return new DebugCompiledQuery(compiled.Query, QueryVariables, compiled.Markers);

        }

        internal void CompileInternal(QueryWriter writer, CompileContext? context = null)
        {
            SchemaInfo ??= context?.SchemaInfo;
            context ??= new();

            List<IDictionary<string, object?>> parameters = new();

            var nodes = Nodes;

            if (!context.IncludeAutogeneratedNodes)
                nodes = nodes
                    .Where(x => !nodes.Any(y => y.SubNodes.Contains(x)) || !x.IsAutoGenerated)
                    .ToList();

            // reference the introspection and finalize all nodes.
            foreach (var node in nodes)
            {
                node.SchemaInfo ??= SchemaInfo;
                context.PreFinalizerModifier?.Invoke(node);
            }

            for (var i = 0; i != nodes.Count; i++)
            {
                nodes[i].FinalizeQuery(writer);
                parameters.Add(nodes[i].Builder.QueryVariables);

                if (i != nodes.Count - 1)
                    writer.Append(' ');
            }

            // reduce the query
            QueryReducer.Apply(this, writer);

            // create a with block if we have any globals
            if (context.IncludeGlobalsInQuery && QueryGlobals.Any())
            {
                var with = (WithNode?)Nodes.FirstOrDefault(x => x is WithNode);

                if (with is null)
                {
                    var builder = new NodeBuilder(new WithContext(typeof(TType)), QueryGlobals, nodes, QueryVariables);

                    with = new WithNode(builder)
                    {
                        SchemaInfo = SchemaInfo
                    };

                    // visit the with node and add it to the front of our local collection of nodes.
                    using (var _ = writer.PositionalScopeFromStart())
                    {
                        with.FinalizeQuery(writer);
                        writer.Append(' ');
                    }

                    nodes = nodes.Prepend(with).ToList();
                }
            }

            // flatten our parameters into a single collection and make it distinct.
            var variables = parameters
                            .SelectMany(x => x)
                            .DistinctBy(x => x.Key);

            // add any variables that might have been added by other builders in a sub-query context.
            variables = variables.Concat(QueryVariables.Where(x => !variables.Any(x => x.Key == x.Key)));
        }

        /// <inheritdoc/>
        public CompiledQuery Compile(bool debug = false)
            => CompileInternal(new CompileContext {Debug = debug});

        /// <inheritdoc/>
        public ValueTask<CompiledQuery> CompileAsync(IEdgeDBQueryable edgedb, bool debug = false, CancellationToken token = default)
            => IntrospectAndCompileAsync(edgedb, debug, token);

        /// <summary>
        ///     Preforms introspection and then compiles this query builder into a <see cref="CompiledQuery"/>.
        /// </summary>
        /// <param name="edgedb">The client to preform introspection with.</param>
        /// <param name="token">A cancellation token to cancel the introspection query.</param>
        /// <returns>
        ///     A ValueTask representing the (a)sync introspection and compiling operation.
        ///     The result is the compiled form of this query builder.
        /// </returns>
        private async ValueTask<CompiledQuery> IntrospectAndCompileAsync(IEdgeDBQueryable edgedb, bool debug, CancellationToken token)
        {
            if (Nodes.Any(x => x.RequiresIntrospection) || QueryGlobals.Any(x => x.Value is SubQuery subQuery && subQuery.RequiresIntrospection))
                SchemaInfo ??= await SchemaIntrospector.GetOrCreateSchemaIntrospectionAsync(edgedb, token).ConfigureAwait(false);

            var result = Compile(debug);
            Nodes.Clear();
            QueryGlobals.Clear();

            return result;
        }

        #region Generic sub-query methods
        private QueryBuilder<TType, TContext> By(LambdaExpression selector)
        {
            if(CurrentUserNode is not GroupNode groupNode)
                throw new InvalidOperationException($"Cannot add a 'by' expression on a {CurrentUserNode}");

            groupNode.By(selector);
            return this;
        }

        private QueryBuilder<TType, TNewContext> Using<TNewContext, TUsing>(LambdaExpression expression)
            where TNewContext : IQueryContextUsing<TUsing>
        {
            if(CurrentUserNode is not GroupNode groupNode)
                throw new InvalidOperationException($"Cannot add a 'by' expression on a {CurrentUserNode}");

            groupNode.Using(expression);
            return EnterNewContext<TNewContext>();
        }


        /// <summary>
        ///     Adds a 'FILTER' statement to the current node.
        /// </summary>
        /// <param name="filter">The filter lambda to add</param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node doesn't support a filter statement.
        /// </exception>
        private QueryBuilder<TType, TContext> Filter(LambdaExpression filter)
        {
            switch (CurrentUserNode)
            {
                case SelectNode selectNode:
                    selectNode.Filter(filter);
                    break;
                case UpdateNode updateNode:
                    updateNode.Filter(filter);
                    break;
                default:
                    throw new InvalidOperationException($"Cannot filter on a {CurrentUserNode}");
            }
            return this;
        }

        /// <summary>
        ///     Adds a 'ORDER BY' statement to the current node.
        /// </summary>
        /// <param name="asc">
        ///     <see langword="true"/> if the ordered result should be ascending first.
        /// </param>
        /// <param name="selector">The lambda property selector on which to order by.</param>
        /// <param name="placement">The <see langword="null"/> placement for null values.</param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support order by statements
        /// </exception>
        private QueryBuilder<TType, TContext> OrderBy(bool asc, LambdaExpression selector, OrderByNullPlacement? placement)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot order by on a {CurrentUserNode}");

            selectNode.OrderBy(asc, selector, placement);

            return this;
        }

        /// <summary>
        ///     Adds a 'OFFSET' statement to the current node.
        /// </summary>
        /// <param name="offset">The amount to offset by.</param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support offset statements.
        /// </exception>
        private QueryBuilder<TType, TContext> Offset(long offset)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot offset on a {CurrentUserNode}");

            selectNode.Offset(offset);

            return this;
        }

        /// <summary>
        ///     Adds a 'OFFSET' statement to the current node.
        /// </summary>
        /// <param name="offset">The lambda function of which the result is the amount to offset by.</param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support offset statements.
        /// </exception>
        private QueryBuilder<TType, TContext> OffsetExp(LambdaExpression offset)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot offset on a {CurrentUserNode}");

            selectNode.OffsetExpression(offset);

            return this;
        }

        /// <summary>
        ///     Adds a 'LIMIT' statement to the current node.
        /// </summary>
        /// <param name="limit">The amount to limit by.</param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support limit statements.
        /// </exception>
        private QueryBuilder<TType, TContext> Limit(long limit)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot limit on a {CurrentUserNode}");

            selectNode.Limit(limit);

            return this;
        }

        /// <summary>
        ///     Adds a 'LIMIT' statement to the current node.
        /// </summary>
        /// <param name="limit">The lambda function of which the result is the amount to limit by.</param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support limit statements.
        /// </exception>
        private QueryBuilder<TType, TContext> LimitExp(LambdaExpression limit)
        {
            if (CurrentUserNode is not SelectNode selectNode)
                throw new InvalidOperationException($"Cannot limit on a {CurrentUserNode}");

            selectNode.LimitExpression(limit);

            return this;
        }

        /// <summary>
        ///     Adds a 'UNLESS CONFLICT ON' statement to the current node.
        /// </summary>
        /// <remarks>
        ///     This function causes the node to preform introspection.
        /// </remarks>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support unless conflict on statements.
        /// </exception>
        private QueryBuilder<TType, TContext> UnlessConflict()
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot unless conflict on a {CurrentUserNode}");

            insertNode.UnlessConflict();

            return this;
        }

        /// <summary>
        ///     Adds a 'UNLESS CONFLICT ON' statement to the current node.
        /// </summary>
        /// <param name="selector">
        ///     The property selector of which to add the conflict expression to.
        /// </param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support unless conflict on statements.
        /// </exception>
        private QueryBuilder<TType, TContext> UnlessConflictOn(LambdaExpression selector)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot unless conflict on a {CurrentUserNode}");

            insertNode.UnlessConflictOn(selector);

            return this;
        }

        /// <summary>
        ///     Adds a 'ELSE (SELECT <typeparamref name="TType"/>)' statement to the current node.
        /// </summary>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support else statements.
        /// </exception>
        private QueryBuilder<TType, TContext> ElseReturnDefault()
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else return on a {CurrentUserNode}");

            insertNode.ElseDefault();

            return this;
        }

        /// <summary>
        ///     Adds a 'ELSE' statement to the current node.
        /// </summary>
        /// <param name="builder">The query builder for the else statement.</param>
        /// <returns>A query builder representing an unknown return type.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support else statements
        /// </exception>
        private IQueryBuilder<object?, TContext> ElseJoint(IQueryBuilder builder)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else on a {CurrentUserNode}");

            insertNode.Else(builder);

            return EnterNewType<object?>();
        }

        /// <summary>
        ///     Adds a 'ELSE' statement to the current node.
        /// </summary>
        /// <param name="func">
        ///     A function that returns a multi-cardinality query from the provided builder.
        /// </param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support else statements.
        /// </exception>
        private QueryBuilder<TType, TContext> Else(Func<IQueryBuilder<TType, TContext>, IMultiCardinalityQuery<TType>> func)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else on a {CurrentUserNode}");

            var builder = new QueryBuilder<TType, TContext>(_state with
            {
                Nodes = new(),
                Variables = new()
            });

            func(builder);
            insertNode.Else(builder);

            return this;
        }

        /// <summary>
        ///     Adds a 'ELSE' statement to the current node.
        /// </summary>
        /// <param name="func">
        ///     A function that returns a single-cardinality query from the provided builder.
        /// </param>
        /// <returns>The current builder.</returns>
        /// <exception cref="InvalidOperationException">
        ///     The current node does not support else statements.
        /// </exception>
        private QueryBuilder<TType, TContext> Else(Func<IQueryBuilder<TType, TContext>, ISingleCardinalityQuery<TType>> func)
        {
            if (CurrentUserNode is not InsertNode insertNode)
                throw new InvalidOperationException($"Cannot else on a {CurrentUserNode}");

            var builder = new QueryBuilder<TType, TContext>(_state with
            {
                Nodes = new(),
                Variables = new()
            });
            func(builder);
            insertNode.Else(builder);

            return this;
        }

        #endregion

        /// <inheritdoc/>
        async Task<IReadOnlyCollection<TType?>> IMultiCardinalityExecutable<TType>.ExecuteAsync(IEdgeDBQueryable edgedb,
            Capabilities? capabilities, CancellationToken token)
        {
            var result = await IntrospectAndCompileAsync(edgedb, false, token).ConfigureAwait(false);
            return await edgedb.QueryAsync<TType>(result.Query, result.RawVariables, capabilities, token).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        async Task<TType?> ISingleCardinalityExecutable<TType>.ExecuteAsync(IEdgeDBQueryable edgedb,
            Capabilities? capabilities, CancellationToken token)
        {
            var result = await IntrospectAndCompileAsync(edgedb, false, token).ConfigureAwait(false);
            return await edgedb.QuerySingleAsync<TType>(result.Query, result.RawVariables, capabilities, token).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        async Task<TType?> IMultiCardinalityExecutable<TType>.ExecuteSingleAsync(IEdgeDBQueryable edgedb, Capabilities? capabilities, CancellationToken token)
        {
            var result = await IntrospectAndCompileAsync(edgedb, false, token).ConfigureAwait(false);
            return await edgedb.QuerySingleAsync<TType>(result.Query, result.RawVariables, capabilities, token).ConfigureAwait(false);
        }

        /// <inheritdoc/>
        async Task<TType> IMultiCardinalityExecutable<TType>.ExecuteRequiredSingleAsync(IEdgeDBQueryable edgedb, Capabilities? capabilities, CancellationToken token)
        {
            var result = await IntrospectAndCompileAsync(edgedb, false, token).ConfigureAwait(false);
            return await edgedb.QueryRequiredSingleAsync<TType>(result.Query, result.RawVariables, capabilities, token).ConfigureAwait(false);
        }


        #region IQueryBuilder<TType>

        SchemaInfo? IQueryBuilder.SchemaInfo => SchemaInfo;
        IReadOnlyCollection<QueryNode> IQueryBuilder.Nodes => Nodes;
        List<QueryGlobal> IQueryBuilder.Globals => QueryGlobals;
        Dictionary<string, object?> IQueryBuilder.Variables => QueryVariables;

        void IQueryBuilder.CompileInternal(QueryWriter writer, CompileContext? context) =>
            CompileInternal(writer, context);

        #endregion
    }

}
