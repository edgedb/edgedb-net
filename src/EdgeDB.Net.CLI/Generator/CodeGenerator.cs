using EdgeDB.Binary.Codecs;
using EdgeDB.CLI;
using EdgeDB.CLI.Generator.Models;
using EdgeDB.CLI.Generator.Results;
using EdgeDB.CLI.Utils;
using System;
using System.Reflection;
using System.Text.RegularExpressions;

namespace EdgeDB.CLI.Generator
{
    internal class CodeGenerator
    {
        /// <summary>
        ///     The file header regex for generate C# files.
        /// </summary>
        private static readonly Regex _headerHashRegex = new(@"\/\/ edgeql:([0-9a-fA-F]{64})");

        /// <summary>
        ///     Parses and generates a <see cref="GenerationResult"/> from a given client and
        ///     <see cref="GenerationTargetInfo"/>.
        /// </summary>
        /// <param name="client">The client to preform the parse with.</param>
        /// <param name="namespace">The namespace for the <see cref="GenerationResult"/>.</param>
        /// <param name="targetInfo">
        ///     The information containimg the edgeql and related
        ///     content used to parse and generate.</param>
        /// <returns>
        ///     A <see cref="GenerationResult"/> containing the generated C# code, hash,
        ///     classname, and executer name.
        /// </returns>
        public static async Task<GenerationResult> ParseAndGenerateAsync(EdgeDBTcpClient client, string outputDir, string @namespace, GenerationTargetInfo targetInfo)
        {
            var parseResult = await client.ParseAsync(targetInfo.EdgeQL!, Cardinality.Many, IOFormat.Binary, Capabilities.All, false, default);

            return Generate(outputDir, @namespace, targetInfo, parseResult);
        }

        /// <summary>
        ///     Checks whether an autogenerate header matches a hash.
        /// </summary>
        /// <param name="header">The header of the autogenerated file to check against.</param>
        /// <param name="hash">The hash to check.</param>
        /// <returns>
        ///     <see langword="true"/> if the header matches the hash; otherwise <see langword="false"/>.
        /// </returns>
        public static bool TargetFileHashMatches(string header, string hash)
        {
            var match = _headerHashRegex.Match(header);
            if (!match.Success)
                return false;
            return match.Groups[1].Value == hash;
        }

        /// <summary>
        ///     Gets the <see cref="GenerationTargetInfo"/> for the given file and
        ///     generation target directory.
        /// </summary>
        /// <remarks>
        ///     This operation requires the file to be opened. This function will
        ///     throw if the file is being used by a different process.
        /// </remarks>
        /// <param name="edgeqlFilePath">The path of the edgeql file.</param>
        /// <param name="targetDir">The output target directory.</param>
        /// <returns>
        ///     The <see cref="GenerationTargetInfo"/> for the given file.
        /// </returns>
        public static GenerationTargetInfo GetTargetInfo(string edgeqlFilePath, string targetDir)
        {
            string fileContent = File.ReadAllText(edgeqlFilePath);
            var hash = HashUtils.HashEdgeQL(fileContent);
            var fileName = TextUtils.ToPascalCase(Path.GetFileName(edgeqlFilePath).Split('.')[0]);

            return new GenerationTargetInfo
            {
                EdgeQLFileNameWithoutExtension = fileName,
                EdgeQL = fileContent,
                EdgeQLHash = hash,
                EdgeQLFilePath = edgeqlFilePath,
                TargetFilePath = Path.Combine(targetDir, $"{fileName}.g.cs")
            };
        }

        /// <summary>
        ///     Generates a <see cref="GenerationResult"/> from the given <see cref="GenerationTargetInfo"/>
        ///     and <see cref="EdgeDBBinaryClient.ParseResult"/>.
        /// </summary>
        /// <param name="namespace">The namepsace for the generated code to consume.</param>
        /// <param name="targetInfo">The <see cref="GenerationTargetInfo"/> used for generation.</param>
        /// <param name="parseResult">The parse result from edgedb.</param>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException"></exception>
        private static GenerationResult Generate(string outputDir, string @namespace, GenerationTargetInfo targetInfo, ParseResult parseResult)
        {
            var codecType = GetTypeInfoFromCodec(parseResult.OutCodec.Codec, $"{targetInfo.EdgeQLFileNameWithoutExtension}Result");

            var visitor = new ResultVisitor();
            var resultInfo = codecType.Build();
            resultInfo.Visit(visitor);

            foreach(var type in visitor.GenerationTargets)
            {
                TypeGenerator.GenerateType(outputDir, @namespace, type);
            }

            // create the class writer
            var writer = new CodeWriter();
            writer.AppendLine("// AUTOGENERATED: DO NOT MODIFY");
            writer.AppendLine($"// edgeql:{targetInfo.EdgeQLHash}");
            writer.AppendLine($"// Generated on {DateTime.UtcNow:O}");
            writer.AppendLine("#nullable enable");
            writer.AppendLine($"using EdgeDB;");

            writer.AppendLine();
            writer.AppendLine($"namespace {@namespace};");
            writer.AppendLine();

            // create the executor class
            var classScope = writer.BeginScope($"public static class {targetInfo.EdgeQLFileNameWithoutExtension}");

            writer.AppendLine($"public static readonly string Query = @\"{targetInfo.EdgeQL}\";");
            writer.AppendLine();
            var method = parseResult.Cardinality switch
            {
                Cardinality.AtMostOne => "QuerySingleAsync",
                Cardinality.One => "QueryRequiredSingleAsync",
                _ => "QueryAsync"
            };

            var rawResultType = resultInfo.ToCSharp();

            var resultType = parseResult.Cardinality switch
            {
                Cardinality.AtMostOne => $"{rawResultType}?",
                Cardinality.One => rawResultType,
                _ => $"IReadOnlyCollection<{rawResultType}?>"
            };

            // build args
            IEnumerable<string>? argParameters;
            IEnumerable<string>? methodArgs;

            if (parseResult.InCodec.Codec is NullCodec)
            {
                methodArgs = Array.Empty<string>();
                argParameters = Array.Empty<string>();
            }
            else if (parseResult.InCodec.Codec is Binary.Codecs.Object argCodec)
            {
                argParameters = argParameters = argCodec.PropertyNames.Select((x, i) =>
                {
                    var codec = argCodec.InnerCodecs[i];
                    var codecInfo = GetTypeInfoFromCodec(codec, x);

                    return $"{codecInfo.Build().ToCSharp()} {TextUtils.ToCamelCase(x)}";
                });

                methodArgs = methodArgs = argCodec.PropertyNames.Select((x, i) =>
                {
                    return $"{{ \"{x}\", {TextUtils.ToCamelCase(x)} }}";
                });
            }
            else
                throw new InvalidOperationException("Argument codec is malformed");

            writer.AppendLine($"public static Task<{resultType}> ExecuteAsync(IEdgeDBQueryable client{(argParameters.Any() ? $", {string.Join(", ", argParameters)}" : "")}, CancellationToken token = default)");
            writer.AppendLine($"    => client.{method}<{rawResultType}>(Query{(methodArgs.Any() ? $", new Dictionary<string, object?>() {{ {string.Join(", ", methodArgs)} }}" : "")}, capabilities: (Capabilities){(ulong)parseResult.Capabilities}ul, token: token);");

            writer.AppendLine();
            writer.AppendLine($"public static Task<{resultType}> {targetInfo.EdgeQLFileNameWithoutExtension}Async(this IEdgeDBQueryable client{(argParameters.Any() ? $", {string.Join(", ", argParameters)}" : "")}, CancellationToken token = default)");
            writer.AppendLine($"    => ExecuteAsync(client{(argParameters.Any() ? $", {string.Join(", ", argParameters.Select(x => x.Split(' ')[1]))}" : "")}, token: token);");

            classScope.Dispose();

            writer.AppendLine("#nullable restore");

            return new()
            {
                ExecuterClassName = targetInfo.EdgeQLFileNameWithoutExtension,
                EdgeQLHash = targetInfo.EdgeQLHash,
                ReturnResult = resultType,
                Parameters = argParameters,
                Code = writer.ToString()
            };
        }

        /// <summary>
        ///     Creates a <see cref="CodecTypeInfo"/> from the given <see cref="ICodec"/>.
        /// </summary>
        /// <param name="codec">The codec to get the type info for.</param>
        /// <param name="name">The optional name of the codec.</param>
        /// <param name="parent">The optional parent of the codec.</param>
        /// <returns>
        ///     A <see cref="CodecTypeInfo"/> representing type information about the provided codec.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///     No <see cref="CodecTypeInfo"/> could be created from the provided codec.
        /// </exception>
        private static CodecTypeInfo GetTypeInfoFromCodec(ICodec codec, string? name = null, CodecTypeInfo? parent = null)
        {
            CodecTypeInfo info;

            switch (codec)
            {
                case Binary.Codecs.Object obj:
                    {
                        info = new CodecTypeInfo
                        {
                            Type = CodecType.Object,
                            TypeName = TextUtils.ToPascalCase(name!)
                        };
                        info.Children = obj.InnerCodecs
                            .Select((x, i) =>
                                obj.PropertyNames[i] is "__tname__" or "__tid__"
                                    ? null
                                    : GetTypeInfoFromCodec(x, obj.PropertyNames[i], info))
                            .Where(x => x is not null)!;
                    }
                    break;
                case ICodec set when ReflectionUtils.IsSubclassOfRawGeneric(typeof(Set<>), set.GetType()):
                    {
                        info = new CodecTypeInfo
                        {
                            Type = CodecType.Array,
                        };
                        info.Children = new[]
                        {
                            GetTypeInfoFromCodec((ICodec)set.GetType().GetField("_innerCodec", BindingFlags.Instance | BindingFlags.NonPublic)!.GetValue(set)!, parent: info)
                        };
                    }
                    break;
                case ICodec array when ReflectionUtils.IsSubclassOfRawGeneric(typeof(Array<>), array.GetType()):
                    {
                        info = new CodecTypeInfo
                        {
                            Type = CodecType.Set,
                        };
                        info.Children = new[]
                        {
                            GetTypeInfoFromCodec((ICodec)array.GetType().GetField("_innerCodec", BindingFlags.Instance | BindingFlags.NonPublic)!.GetValue(array)!, parent: info)
                        };
                    }
                    break;
                case Binary.Codecs.Tuple tuple:
                    {
                        info = new CodecTypeInfo
                        {
                            Type = CodecType.Tuple,
                        };
                        info.Children = tuple.InnerCodecs.Select(x => GetTypeInfoFromCodec(x, parent: info));
                    }
                    break;
                case ICodec scalar when ReflectionUtils.IsSubclassOfInterfaceGeneric(typeof(IScalarCodec<>), codec!.GetType()):
                    {
                        var scalarTarget = codec.GetType().GetInterface("IScalarCodec`1")!.GetGenericArguments()[0];
                        info = new CodecTypeInfo
                        {
                            Namespace = scalarTarget.Namespace,
                            TypeName = $"{scalarTarget.ToFormattedString()}{(scalarTarget.IsValueType ? "" : "?")}",
                        };
                    }
                    break;
                default:
                    throw new InvalidOperationException($"Unknown codec {codec}");
            }

            info.Name = name ?? info.Name;
            info.Parent = parent;

            return info;
        }
    }
}

