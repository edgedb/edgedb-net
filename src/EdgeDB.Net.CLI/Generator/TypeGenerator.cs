using EdgeDB.CLI.Generator.Models;
using EdgeDB.CLI.Generator.Results;
using EdgeDB.CLI.Utils;
using YamlDotNet.Serialization;
using System;
using YamlDotNet.Serialization.NamingConventions;
using System.Text.RegularExpressions;

namespace EdgeDB.CLI.Generator
{
    /// <summary>
    ///     A class responsible for generating c# types from intermediate representations.
    /// </summary>
    internal class TypeGenerator
    {
        /// <summary>
        ///     The regex used to match the generation hash within type files.
        /// </summary>
        private static readonly Regex _genHashRegex = new(@"^\/\/ GENHASH:(.{64})$");
        
        /// <summary>
        ///     A dictionary mapping function names and their corrisponding result types.
        /// </summary>
        private static readonly Dictionary<string, IQueryResult> _functionResultInfo;

        static TypeGenerator()
        {
            _functionResultInfo = new();
        }

        /// <summary>
        ///     Removes a given function result info from the type generator.
        /// </summary>
        /// <param name="function">The function whos result to remove.</param>
        public static void RemoveFunctionInfo(string function)
        {
            _functionResultInfo.Remove(function);
        }

        /// <summary>
        ///     Renames a function result info in the type generator.
        /// </summary>
        /// <param name="oldName">The old (current) name of the info to rename.</param>
        /// <param name="newName">The new name for the function result info.</param>
        public static void RenameFunctionInfo(string oldName, string newName)
        {
            if(_functionResultInfo.TryGetValue(oldName, out var result))
            {
                _functionResultInfo.Remove(oldName);
                _functionResultInfo[newName] = result;
            }
        }

        /// <summary>
        ///     Updates a function result info to a newer version.
        /// </summary>
        /// <param name="function">The function whos result to update.</param>
        /// <param name="result">The newer result of the function.</param>
        public static void UpdateResultInfo(string function, IQueryResult result)
        {
            _functionResultInfo[function] = result;
        }

        /// <summary>
        ///     Generates a single C# type from the given <see cref="ClassResult"/>. This function mutates the
        ///     result based off of the <see cref="TypeManifest"/>.
        /// </summary>
        /// <param name="outputDir">The output directory where types will be placed.</param>
        /// <param name="namespace">The namespace to use when generating the types.</param>
        /// <param name="result">The result info to use when generating the type.</param>
        /// <returns>The path of the generated file.</returns>
        public static async Task<string> GenerateTypeAsync(string outputDir, string @namespace, ClassResult result)
        {
            var path = Path.Combine(GetTypeOutputDir(outputDir), $"{result.ClassName}.g.cs");

            var hash = result.GetClassHash();
            
            if(File.Exists(path))
            {
                // check if the hash matches
                var hashLine = File.ReadLines(path).ElementAt(1);

                var match = _genHashRegex.Match(hashLine);

                if (match.Success && match.Groups[1].Value == hash)
                {
                    // no changes, skip generation and return the path.
                    return path;
                }

                // no need to fail if the regex doesn't match, we can just rewrite the file.
            }

            var writer = new CodeWriter();

            writer.AppendLine("// AUTOGENERATED: DO NOT MODIFY");
            writer.AppendLine($"// GENHASH:{hash}");
            writer.AppendLine($"// Generated on {DateTime.UtcNow:O}");
            writer.AppendLine();

            writer.AppendLine("using EdgeDB;");

            foreach(var ns in result.UsedNamespaces)
            {
                writer.AppendLine($"using {ns};");
            }

            writer.AppendLine();

            writer.AppendLine($"namespace {@namespace};");
            writer.AppendLine();

            writer.AppendLine("#nullable enable");

            writer.AppendLine("[EdgeDBType]");
            writer.Append("public partial ");

            if (result.IsAbstract)
                writer.Append("abstract ");

            writer.Append($"class {result.ClassName}");

            if (result.Extending is not null)
                writer.Append($" : {result.Extending}");

            writer.AppendLine();

            using(_ = writer.BeginScope())
            {
                foreach(var property in result.Properties)
                {
                    writer.AppendLine($"[EdgeDBProperty(\"{property.Key}\")]");
                    writer.AppendLine($"public {property.Value.ToCSharp()} {TextUtils.ToPascalCase(property.Key)} {{ get; set; }}");

                    if(result.Properties.Last().Key != property.Key)
                        writer.AppendLine();
                }
            }

            writer.AppendLine("#nullable restore");

            await File.WriteAllTextAsync(path, writer.ToString());

            return path;
        }
        
        /// <summary>
        ///     Gets or creates the directory for the generated types.
        /// </summary>
        /// <param name="rootOutputDir">The root output directory.</param>
        /// <returns>The directory that types will be outputed in.</returns>
        private static string GetTypeOutputDir(string rootOutputDir)
        {
            var path = Path.Combine(rootOutputDir, "Types");

            Directory.CreateDirectory(path);

            return path;
        }
    }
}
