using EdgeDB.CLI.Generator.Models;
using EdgeDB.CLI.Generator.Models.TypeManifest;
using EdgeDB.CLI.Generator.Results;
using EdgeDB.CLI.Utils;
using YamlDotNet.Serialization;
using System;
using YamlDotNet.Serialization.NamingConventions;
using System.Text.RegularExpressions;

namespace EdgeDB.CLI.Generator
{
    /// <summary>
    ///     A class responsible for generating c# types from intermediate representations.
    /// </summary>
    internal class TypeGenerator
    {
        /// <summary>
        ///     Gets the type manifest for the generator.
        /// </summary>
        public static TypeManifest? TypeManifest { get; private set; }

        /// <summary>
        ///     The regex used to match the generation hash within type files.
        /// </summary>
        private static readonly Regex _genHashRegex = new(@"^\/\/ GENHASH:(.{64})$");

        /// <summary>
        ///     The YAML deserializer used to deserialize the type manifest file.
        /// </summary>
        private static readonly IDeserializer _yamlDeserializer;

        /// <summary>
        ///     A dictionary mapping function names and their corrisponding result types.
        /// </summary>
        private static readonly Dictionary<string, IQueryResult> _functionResultInfo;

        static TypeGenerator()
        {
            _yamlDeserializer = new DeserializerBuilder()
                .WithNamingConvention(UnderscoredNamingConvention.Instance)
                .Build();

            _functionResultInfo = new();
        }

        /// <summary>
        ///     Removes a given function result info from the type generator.
        /// </summary>
        /// <param name="function">The function whos result to remove.</param>
        public static void RemoveFunctionInfo(string function)
        {
            _functionResultInfo.Remove(function);
        }

        /// <summary>
        ///     Renames a function result info in the type generator.
        /// </summary>
        /// <param name="oldName">The old (current) name of the info to rename.</param>
        /// <param name="newName">The new name for the function result info.</param>
        public static void RenameFunctionInfo(string oldName, string newName)
        {
            if(_functionResultInfo.TryGetValue(oldName, out var result))
            {
                _functionResultInfo.Remove(oldName);
                _functionResultInfo[newName] = result;
            }
        }

        /// <summary>
        ///     Updates a function result info to a newer version.
        /// </summary>
        /// <param name="function">The function whos result to update.</param>
        /// <param name="result">The newer result of the function.</param>
        public static void UpdateResultInfo(string function, IQueryResult result)
        {
            _functionResultInfo[function] = result;
        }

        /// <summary>
        ///     Generates a single C# type from the given <see cref="ClassResult"/>. This function mutates the
        ///     result based off of the <see cref="TypeManifest"/>.
        /// </summary>
        /// <param name="outputDir">The output directory where types will be placed.</param>
        /// <param name="namespace">The namespace to use when generating the types.</param>
        /// <param name="result">The result info to use when generating the type.</param>
        /// <returns>The path of the generated file.</returns>
        public static async Task<string> GenerateTypeAsync(string outputDir, string @namespace, ClassResult result)
        {
            await ApplyOverridesAsync(outputDir, result);

            var path = Path.Combine(GetTypeOutputDir(outputDir), $"{result.ClassName}.g.cs");

            var hash = result.GetClassHash();
            
            if(File.Exists(path))
            {
                // check if the hash matches
                var hashLine = File.ReadLines(path).ElementAt(1);

                var match = _genHashRegex.Match(hashLine);

                if (match.Success && match.Groups[1].Value == hash)
                {
                    // no changes, skip generation and return the path.
                    return path;
                }

                // no need to fail if the regex doesn't match, we can just rewrite the file.
            }

            var writer = new CodeWriter();

            writer.AppendLine("// AUTOGENERATED: DO NOT MODIFY");
            writer.AppendLine($"// GENHASH:{hash}");
            writer.AppendLine($"// Generated on {DateTime.UtcNow:O}");
            writer.AppendLine();

            writer.AppendLine("using EdgeDB;");

            foreach(var ns in result.UsedNamespaces)
            {
                writer.AppendLine($"using {ns};");
            }

            writer.AppendLine();

            writer.AppendLine($"namespace {@namespace};");
            writer.AppendLine();

            writer.AppendLine("#nullable enable");

            writer.AppendLine("[EdgeDBType]");
            writer.Append("public partial ");

            if (result.IsAbstract)
                writer.Append("abstract ");

            writer.Append($"class {result.ClassName}");

            if (result.Extending is not null)
                writer.Append($" : {result.Extending}");

            writer.AppendLine();

            using(_ = writer.BeginScope())
            {
                foreach(var property in result.Properties)
                {
                    writer.AppendLine($"[EdgeDBProperty(\"{property.Key}\")]");
                    writer.AppendLine($"public {property.Value.ToCSharp()} {TextUtils.ToPascalCase(property.Key)} {{ get; set; }}");

                    if(result.Properties.Last().Key != property.Key)
                        writer.AppendLine();
                }
            }

            writer.AppendLine("#nullable restore");

            await File.WriteAllTextAsync(path, writer.ToString());

            return path;
        }

        /// <summary>
        ///     Applies mutations defined in the <see cref="TypeManifest"/> to a given <see cref="ClassResult"/>.
        /// </summary>
        /// <param name="dir">The directory that contains the type manifest.</param>
        /// <param name="result">The class result to mutate.</param>
        /// <returns>A task representing the asynchronous operation of mutating the class.</returns>
        private static async Task ApplyOverridesAsync(string dir, ClassResult result)
        {
            TypeManifest ??= await LoadTypeManifestAsync(dir);

            if (!TypeManifest.TryGetDefinition(result.FileName, out var definition))
                return; // no overrides, default generation behaviour

            // apply property resolving
            Dictionary<string, IQueryResult> targetProperies = new();

            switch (definition.PropertyMode)
            {
                case PropertyMode.All:
                    {
                        targetProperies = definition.Functions.Select(x =>
                        {
                            if (_functionResultInfo.TryGetValue(x, out var v) && v is ClassResult cr)
                            {
                                return cr.Properties;
                            }

                            return null;
                        })
                            .Where(x => x is not null)
                            .SelectMany(x => x!.ToArray())
                            .DistinctBy(x => x.Key)
                            .ToDictionary(x => x.Key, x => x.Value);
                    }
                    break;
                case PropertyMode.Shared:
                    {
                        var temp = definition.Functions.Select(x =>
                        {
                            if (_functionResultInfo.TryGetValue(x, out var v) && v is ClassResult cr)
                            {
                                return cr.Properties;
                            }

                            return null;
                        }).Where(x => x is not null);

                        targetProperies = temp
                            .SelectMany(x => x!.Where(y => temp.Any(z => z != x && z!.Any(q => q.Key == y.Key))))
                            .DistinctBy(x => x.Key)
                            .ToDictionary(x => x.Key, x => x.Value);
                    }
                    break;
            }

            result.Properties = targetProperies;

            // apply property type changes
            foreach (var typeOverride in definition.TypeOverrides)
            {
                if(targetProperies.TryGetValue(typeOverride.Key, out var prop))
                {
                    targetProperies[typeOverride.Key] = new ScalarResult(prop.FilePath, typeOverride.Value);
                }
            }

            // apply the class name
            result.ClassName = definition.Name!;
        }

        /// <summary>
        ///     Loads the type manifest from the given directory.
        /// </summary>
        /// <param name="dir">The directory that contains the type manifest.</param>
        /// <returns>A ValueTask whos result is the loaded type manifest.</returns>
        private static async ValueTask<TypeManifest> LoadTypeManifestAsync(string dir)
        {
            var path = Path.Combine(dir, "TypeManifest.yaml");

            if (!File.Exists(path))
            {
                File.WriteAllText(path, "types:");
                return new TypeManifest();
            }

            var yaml = await File.ReadAllTextAsync(path);

            return _yamlDeserializer.Deserialize<TypeManifest>(yaml);
        }

        /// <summary>
        ///     Gets or creates the directory for the generated types.
        /// </summary>
        /// <param name="rootOutputDir">The root output directory.</param>
        /// <returns>The directory that types will be outputed in.</returns>
        private static string GetTypeOutputDir(string rootOutputDir)
        {
            var path = Path.Combine(rootOutputDir, "Types");

            Directory.CreateDirectory(path);

            return path;
        }
    }
}
