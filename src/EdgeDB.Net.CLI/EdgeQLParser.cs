using EdgeDB.Binary.Codecs;
using EdgeDB.CLI.Utils;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace EdgeDB.CLI
{
    /// <summary>
    ///     Represents a class responsible for parsing and transpiling edgeql to C#.
    /// </summary>
    internal class EdgeQLParser
    {
        /// <summary>
        ///     The file header regex for generate C# files.
        /// </summary>
        private static readonly Regex _headerHashRegex = new(@"\/\/ edgeql:([0-9a-fA-F]{64})");

        /// <summary>
        ///     Parses and generates a <see cref="GenerationResult"/> from a given client and
        ///     <see cref="GenerationTargetInfo"/>.
        /// </summary>
        /// <param name="client">The client to preform the parse with.</param>
        /// <param name="namespace">The namespace for the <see cref="GenerationResult"/>.</param>
        /// <param name="targetInfo">
        ///     The information containimg the edgeql and related
        ///     content used to parse and generate.</param>
        /// <returns>
        ///     A <see cref="GenerationResult"/> containing the generated C# code, hash,
        ///     classname, and executer name.
        /// </returns>
        public static async Task<GenerationResult> ParseAndGenerateAsync(EdgeDBTcpClient client, string @namespace, GenerationTargetInfo targetInfo)
        {
            var parseResult = await client.ParseAsync(targetInfo.EdgeQL!, Cardinality.Many, IOFormat.Binary, Capabilities.All, default);

            return GenerateCSharpFromEdgeQL(@namespace, targetInfo, parseResult);
        }

        /// <summary>
        ///     Checks whether an autogenerate header matches a hash.
        /// </summary>
        /// <param name="header">The header of the autogenerated file to check against.</param>
        /// <param name="hash">The hash to check.</param>
        /// <returns>
        ///     <see langword="true"/> if the header matches the hash; otherwise <see langword="false"/>.
        /// </returns>
        public static bool TargetFileHashMatches(string header, string hash)
        {
            var match = _headerHashRegex.Match(header);
            if (!match.Success)
                return false;
            return match.Groups[1].Value == hash;
        }

        /// <summary>
        ///     Gets the <see cref="GenerationTargetInfo"/> for the given file and
        ///     generation target directory.
        /// </summary>
        /// <remarks>
        ///     This operation requires the file to be opened. This function will
        ///     throw if the file is being used by a different process.
        /// </remarks>
        /// <param name="edgeqlFilePath">The path of the edgeql file.</param>
        /// <param name="targetDir">The output target directory.</param>
        /// <returns>
        ///     The <see cref="GenerationTargetInfo"/> for the given file.
        /// </returns>
        public static GenerationTargetInfo GetTargetInfo(string edgeqlFilePath, string targetDir)
        {
            string fileContent = File.ReadAllText(edgeqlFilePath);
            var hash = HashUtils.HashEdgeQL(fileContent);
            var fileName = TextUtils.ToPascalCase(Path.GetFileName(edgeqlFilePath).Split('.')[0]);

            return new GenerationTargetInfo
            {
                EdgeQLFileNameWithoutExtension = fileName,
                EdgeQL = fileContent,
                EdgeQLHash = hash,
                EdgeQLFilePath = edgeqlFilePath,
                TargetFilePath = Path.Combine(targetDir, $"{fileName}.g.cs")
            };
        }

        /// <summary>
        ///     Represents a generation target, containing useful information for it.
        /// </summary>
        public class GenerationTargetInfo
        {
            /// <summary>
            ///     Gets or sets the edgeql file name without extension.
            /// </summary>
            public string? EdgeQLFileNameWithoutExtension { get; set; }

            /// <summary>
            ///     Gets or sets the edgeql file path.
            /// </summary>
            public string? EdgeQLFilePath { get; set; }

            /// <summary>
            ///     Gets or sets the output target file path.
            /// </summary>
            public string? TargetFilePath { get; set; }

            /// <summary>
            ///     Gets or sets the edgeql.
            /// </summary>
            public string? EdgeQL { get; set; }

            /// <summary>
            ///     Gets or sets the hash of the edgeql.
            /// </summary>
            public string? EdgeQLHash { get; set; }

            /// <summary>
            ///     Gets or sets whether or not this is a
            ///     create operation; else is a update operation.
            /// </summary>
            public bool WasCreated { get; set; }

            /// <summary>
            ///     Checks if the target file exists and the header matches the hash of the edgeql.
            /// </summary>
            /// <returns></returns>
            public bool IsGeneratedTargetExistsAndIsUpToDate()
            {
                var lines = File.Exists(TargetFilePath) ? File.ReadAllLines(TargetFilePath) : Array.Empty<string>();

                return File.Exists(TargetFilePath) && lines.Length >= 2 && TargetFileHashMatches(lines[1], EdgeQLHash!);
            }
        }

        /// <summary>
        ///     A class representing the result of a edgeql -> cs generation operation.
        /// </summary>
        public class GenerationResult
        {
            /// <summary>
            ///     Gets the code generated from edgeql.
            /// </summary>
            public string? Code { get; set; }

            /// <summary>
            ///     Gets the hash of the edgeql and header of the generated code.
            /// </summary>
            public string? EdgeQLHash { get; set; }

            /// <summary>
            ///     Gets the name of the class containing the execute method.
            /// </summary>
            public string? ExecuterClassName { get; set; }

            /// <summary>
            ///     Gets the name of the return result that the executer method returns.
            /// </summary>
            public string? ReturnResult { get; set; }

            /// <summary>
            ///     Gets a collection of parameters (edgeql arguments) for the executer function.
            /// </summary>
            public IEnumerable<string>? Parameters { get; set; }
        }

        /// <summary>
        ///     Generates a <see cref="GenerationResult"/> from the given <see cref="GenerationTargetInfo"/>
        ///     and <see cref="EdgeDBBinaryClient.ParseResult"/>.
        /// </summary>
        /// <param name="namespace">The namepsace for the generated code to consume.</param>
        /// <param name="targetInfo">The <see cref="GenerationTargetInfo"/> used for generation.</param>
        /// <param name="parseResult">The parse result from edgedb.</param>
        /// <returns></returns>
        /// <exception cref="InvalidOperationException"></exception>
        private static GenerationResult GenerateCSharpFromEdgeQL(string @namespace, GenerationTargetInfo targetInfo, ParseResult parseResult)
        {
            var codecType = GetTypeInfoFromCodec(parseResult.OutCodec.Codec, $"{targetInfo.EdgeQLFileNameWithoutExtension} Result");

            // create the class writer

            var writer = new CodeWriter();
            writer.AppendLine("// AUTOGENERATED: DO NOT MODIFY");
            writer.AppendLine($"// edgeql:{targetInfo.EdgeQLHash}");
            writer.AppendLine($"// Generated on {DateTime.UtcNow:O}");
            writer.AppendLine("#nullable enable");
            writer.AppendLine($"using EdgeDB;");
            writer.AppendLine();
            writer.AppendLine($"namespace {@namespace};");
            writer.AppendLine();

            var refTypes = new List<CodecTypeInfo>();
            var compliledTypes = new List<(CodecTypeInfo Info, string Reference)?>();

            var mainResult = BuildTypes(codecType, out var typeName, refTypes);

            compliledTypes.Add((codecType, mainResult));

            if (refTypes.Any() || codecType.IsObject)
            {
                var seenTypes = new HashSet<CodecTypeInfo>(refTypes) { codecType };
                var refStack = new Stack<CodecTypeInfo>(refTypes);

                writer.AppendLine("#region Types");
                writer.AppendLine(mainResult);

                // circle dependency safe!
                while (refStack.TryPop(out var typeInfo))
                {
                    var complRef = compliledTypes.FirstOrDefault(x => x!.Value.Info.BodyEquals(typeInfo));

                    if (complRef is not null)
                    {
                        writer.AppendLine(complRef.Value.Reference);
                        continue;
                    }

                    var newTypes = new List<CodecTypeInfo>();
                    var result = BuildTypes(typeInfo, out _, newTypes);

                    if (newTypes.Any())
                        foreach (var newType in newTypes.Where(x => !seenTypes.TryGetValue(x, out _)))
                            refStack.Push(newType);

                    writer.AppendLine(result);
                    compliledTypes.Add((typeInfo, result));
                }

                writer.AppendLine("#endregion");
                writer.AppendLine();
            }

            // create the executor class
            var classScope = writer.BeginScope($"public static class {targetInfo.EdgeQLFileNameWithoutExtension}");

            writer.AppendLine($"public static readonly string Query = @\"{targetInfo.EdgeQL}\";");
            writer.AppendLine();
            var method = parseResult.Cardinality switch
            {
                Cardinality.AtMostOne => "QuerySingleAsync",
                Cardinality.One => "QueryRequiredSingleAsync",
                _ => "QueryAsync"
            };

            var resultType = parseResult.Cardinality switch
            {
                Cardinality.AtMostOne => $"{typeName ?? mainResult}?",
                Cardinality.One => typeName ?? mainResult,
                _ => $"IReadOnlyCollection<{typeName ?? mainResult}?>"
            };

            // build args
            IEnumerable<string>? argParameters;
            IEnumerable<string>? methodArgs;
            if (parseResult.InCodec.Codec is NullCodec)
            {
                methodArgs = Array.Empty<string>();
                argParameters = Array.Empty<string>();
            }
            else if (parseResult.InCodec.Codec is Binary.Codecs.Object argCodec)
            {
                argParameters = argParameters = argCodec.PropertyNames.Select((x, i) => BuildTypes(GetTypeInfoFromCodec(argCodec.InnerCodecs[i], x), out _, namesOnScalar: true, camelCase: true));
                methodArgs = methodArgs = argCodec.PropertyNames.Select((x, i) =>
                {
                    return $"{{ \"{x}\", {TextUtils.ToCamelCase(x)} }}";
                });
            }
            else
                throw new InvalidOperationException("Argument codec is malformed");

            writer.AppendLine($"public static Task<{resultType}> ExecuteAsync(IEdgeDBQueryable client{(argParameters.Any() ? $", {string.Join(", ", argParameters)}" : "")}, CancellationToken token = default)");
            writer.AppendLine($"    => client.{method}<{typeName ?? mainResult}>(Query{(methodArgs.Any() ? $", new Dictionary<string, object?>() {{ {string.Join(", ", methodArgs)} }}" : "")}, capabilities: (Capabilities){(ulong)parseResult.Capabilities}ul, token: token);");

            writer.AppendLine();
            writer.AppendLine($"public static Task<{resultType}> {targetInfo.EdgeQLFileNameWithoutExtension}Async(this IEdgeDBQueryable client{(argParameters.Any() ? $", {string.Join(", ", argParameters)}" : "")}, CancellationToken token = default)");
            writer.AppendLine($"    => ExecuteAsync(client{(argParameters.Any() ? $", {string.Join(", ", argParameters.Select(x => x.Split(' ')[1]))}" : "")}, token: token);");

            classScope.Dispose();

            writer.AppendLine("#nullable restore");

            return new()
            {
                ExecuterClassName = targetInfo.EdgeQLFileNameWithoutExtension,
                EdgeQLHash = targetInfo.EdgeQLHash,
                ReturnResult = resultType,
                Parameters = argParameters,
                Code = writer.ToString()
            };
        }

        /// <summary>
        ///     Builds the C# equivalent type from the given <see cref="CodecTypeInfo"/>.
        /// </summary>
        /// <param name="info">The codec info containing the type information to build.</param>
        /// <param name="resultTypeName">The name of the type or scalar.</param>
        /// <param name="usedObjects">
        ///     The reference to a list of used sub-objects, use to keep track of generated
        ///     reference types.
        /// </param>
        /// <param name="namesOnScalar">
        ///     Whether or not to include the <see cref="CodecTypeInfo.Name"/> on the generated
        ///     result.
        /// </param>
        /// <param name="camelCase">
        ///     Whether or not names will be camel case (<see langword="true"/>) or
        ///     pascal case (<see langword="false"/>).
        /// </param>
        /// <param name="returnTypeName">
        ///     Whether or not to return the type name of objects without generating them. When
        ///     this is <see langword="true"/>, the object info is added to the
        ///     <paramref name="usedObjects"/>.
        /// </param>
        /// <returns>
        ///     The generated C# of the provided <see cref="CodecTypeInfo"/>.
        /// </returns>
        /// <exception cref="InvalidOperationException">The <see cref="CodecTypeInfo"/> is unknown.</exception>
        private static string BuildTypes(CodecTypeInfo info, out string? resultTypeName,
            List<CodecTypeInfo>? usedObjects = null, bool namesOnScalar = false, bool camelCase = false,
            bool returnTypeName = false)
        {
            usedObjects ??= new();
            var writer = new CodeWriter();
            resultTypeName = null;

            var fmtName = info.Name is not null
                ? camelCase
                    ? TextUtils.ToCamelCase(info.Name)
                    : TextUtils.ToPascalCase(info.Name)
                : null;

            if (info.IsObject)
            {
                if (returnTypeName)
                {
                    // add to used objects
                    usedObjects.Add(info);
                    if (namesOnScalar)
                        return $"{info.GetUniqueTypeName()}? {fmtName}";
                    return fmtName!;
                }

                // create the main class
                writer.AppendLine("[EdgeDBType]");
                writer.AppendLine($"public sealed class {info.GetUniqueTypeName()}");
                using (_ = writer.BeginScope())
                {
                    var properties = info.Children!.Select(x =>
                    {
                        var result = BuildTypes(x, out _, usedObjects, namesOnScalar: true, returnTypeName: true);
                        return $"[EdgeDBProperty(\"{x.Name}\")]{Environment.NewLine}    public {result} {{ get; set; }}";
                    });

                    writer.AppendLine(string.Join($"{Environment.NewLine}{Environment.NewLine}    ", properties));
                }

                resultTypeName = info.TypeName!;
                return writer.ToString();
            }

            if (info.IsTuple)
            {
                var types = info.Children!.Select(x => BuildTypes(x, out _, usedObjects, true));
                return $"({string.Join(", ", types)}){(namesOnScalar ? $" {fmtName}" : "")}";
            }

            if (info.IsArray)
            {
                var result = BuildTypes(info.Children!.Single(), out _, usedObjects, true);
                return $"{result}[]{(namesOnScalar ? $" {fmtName}" : "")}";
            }

            if (info.IsSet)
            {
                var result = BuildTypes(info.Children!.Single(), out _, usedObjects, true);
                return $"IEnumerable<{result}>{(namesOnScalar ? $" {fmtName}" : "")}";
            }


            if (info.TypeName is not null)
                return $"{info.TypeName}{(namesOnScalar ? $" {fmtName}" : "")}";

            throw new InvalidOperationException($"Unknown type def {info}");
        }

        /// <summary>
        ///     Creates a <see cref="CodecTypeInfo"/> from the given <see cref="ICodec"/>.
        /// </summary>
        /// <param name="codec">The codec to get the type info for.</param>
        /// <param name="name">The optional name of the codec.</param>
        /// <param name="parent">The optional parent of the codec.</param>
        /// <returns>
        ///     A <see cref="CodecTypeInfo"/> representing type information about the provided codec.
        /// </returns>
        /// <exception cref="InvalidOperationException">
        ///     No <see cref="CodecTypeInfo"/> could be created from the provided codec.
        /// </exception>
        private static CodecTypeInfo GetTypeInfoFromCodec(ICodec codec, string? name = null, CodecTypeInfo? parent = null)
        {
            CodecTypeInfo info;

            switch (codec)
            {
                case Binary.Codecs.Object obj:
                    {
                        info = new CodecTypeInfo
                        {
                            IsObject = true,
                            TypeName = TextUtils.ToPascalCase(name!)
                        };
                        info.Children = obj.InnerCodecs
                            .Select((x, i) =>
                                obj.PropertyNames[i] is "__tname__" or "__tid__"
                                    ? null
                                    : GetTypeInfoFromCodec(x, obj.PropertyNames[i], info))
                            .Where(x => x is not null)!;
                    }
                    break;
                case ICodec set when ReflectionUtils.IsSubclassOfRawGeneric(typeof(Set<>), set.GetType()):
                    {
                        info = new CodecTypeInfo
                        {
                            IsArray = true,
                        };
                        info.Children = new[]
                        {
                        GetTypeInfoFromCodec((ICodec)set.GetType().GetField("_innerCodec", BindingFlags.Instance | BindingFlags.NonPublic)!.GetValue(set)!, parent: info)
                    };
                    }
                    break;
                case ICodec array when ReflectionUtils.IsSubclassOfRawGeneric(typeof(Array<>), array.GetType()):
                    {
                        info = new CodecTypeInfo
                        {
                            IsSet = true,
                        };
                        info.Children = new[]
                        {
                        GetTypeInfoFromCodec((ICodec)array.GetType().GetField("_innerCodec", BindingFlags.Instance | BindingFlags.NonPublic)!.GetValue(array)!, parent: info)
                    };
                    }
                    break;
                case Binary.Codecs.Tuple tuple:
                    {
                        info = new CodecTypeInfo
                        {
                            IsTuple = true,
                        };
                        info.Children = tuple.InnerCodecs.Select(x => GetTypeInfoFromCodec(x, parent: info));
                    }
                    break;
                case ICodec scalar when ReflectionUtils.IsSubclassOfInterfaceGeneric(typeof(IScalarCodec<>), codec!.GetType()):
                    {
                        info = new CodecTypeInfo
                        {
                            TypeName = $"{codec.GetType().GetInterface("IScalarCodec`1")!.GetGenericArguments()[0].Name}{(codec.GetType().GetInterface("IScalarCodec`1")!.GetGenericArguments()[0].IsValueType ? "" : "?")}",
                        };
                    }
                    break;
                default:
                    throw new InvalidOperationException($"Unknown codec {codec}");
            }

            info.Name = name ?? info.Name;
            info.Parent = parent;

            return info;
        }

        /// <summary>
        ///     Represents an expanded form of a <see cref="ICodec"/>, containing
        ///     ease-to-parse information about a codec.
        /// </summary>
        private class CodecTypeInfo
        {
            /// <summary>
            ///     Gets whether or not the codec represents an array.
            /// </summary>
            public bool IsArray { get; init; }

            /// <summary>
            ///     Gets whether or not the codec represents a set.
            /// </summary>
            public bool IsSet { get; init; }

            /// <summary>
            ///     Gets whether or not the codec represents an object.
            /// </summary>
            public bool IsObject { get; init; }

            /// <summary>
            ///     Gets whether or not the codec represents a tuple.
            /// </summary>
            public bool IsTuple { get; init; }

            /// <summary>
            ///     Gets or sets the optional name of the codec.
            /// </summary>
            public string? Name { get; set; }

            /// <summary>
            ///     Gets or sets the optional dotnet type name that represents what the
            ///     codec serializes/deserializes.
            /// </summary>
            public string? TypeName { get; set; }

            /// <summary>
            ///     Gets or sets the child <see cref="CodecTypeInfo"/>s for this parent <see cref="CodecTypeInfo"/>.
            /// </summary>
            public IEnumerable<CodecTypeInfo>? Children { get; set; }

            /// <summary>
            ///     Gets the paret <see cref="CodecTypeInfo"/>.
            /// </summary>
            public CodecTypeInfo? Parent { get; set; }

            /// <summary>
            ///     Checks whether or not the current <see cref="CodecTypeInfo"/>'s body is equal to
            ///     the given <see cref="CodecTypeInfo"/>.
            /// </summary>
            /// <param name="info">
            ///     The <see cref="CodecTypeInfo"/> to check against.
            /// </param>
            /// <returns>
            ///     <see langword="true"/> if the <see cref="CodecTypeInfo"/>'s body matches the
            ///     current <see cref="CodecTypeInfo"/>; otherwise <see langword="false"/>.
            /// </returns>
            public bool BodyEquals(CodecTypeInfo info)
            {
                return IsArray == info.IsArray &&
                       IsSet == info.IsSet &&
                       IsObject == info.IsObject &&
                       IsTuple == info.IsTuple &&
                       (info.Children?.SequenceEqual(Children ?? Array.Empty<CodecTypeInfo>()) ?? false);
            }

            /// <summary>
            ///     Gets a unique name for the current <see cref="CodecTypeInfo"/>.
            /// </summary>
            /// <returns>
            ///     A unique name representing the current <see cref="CodecTypeInfo"/>.
            /// </returns>
            public string GetUniqueTypeName()
            {
                List<string?> path = new() { TypeName };
                var p = Parent;
                while (p is not null)
                {
                    path.Add(p.TypeName);
                    p = p.Parent;
                }
                path.Reverse();
                return string.Join("", path.Where(x => x is not null));
            }

            /// <inheritdoc/>
            public override string ToString()
            {
                return $"{Name} ({TypeName})";
            }
        }
    }
}
